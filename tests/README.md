Validation tests
================

This folder is dedicated to testing the output of the validator, while the more
local tests only test the API. The test runner is written such that there are
no (long*) recompilation times every time a test changes: the tests are parsed
by the test runner on-the-fly.

*the Python-level parser isn't smart enough to do dependency checks, so it just
reruns protoc and re-parses each test every time it's run. At present, this
still happens in the blink of an eye, but as this slows down, it should be made
smarter.

Usage
-----

To run the tests, you will need:

 - Rust/cargo, in order to compile the validator and the test runner; and
 - Python 3.x, with `protobuf`, `pyyaml`, and `click` installed.

After that, just run `python3 runner.py run`. This will "compile" the test
descriptions in the tests folder to a format more easy to understand by the
Rust code (notably, the Rust bindings for protobuf can't read protobuf JSON
serializations) and then run the test runner using cargo.

A whole bunch of files are generated by this process:

 - the `substrait` folder, containing the Python protobuf files for Substrait,
   used by the compiler; and
 - for each test:
    - a `<test.fmt>.test` file, containing the intermediate format passed to
      the Rust test runner;
    - a `<test.fmt>.test.plan.yaml` file, containing the YAML representation of
      the protobuf JSON serialization of the plan, as generated from the test
      description;
    - possibly some `<test.fmt>.*.yaml` files, representing the extension YAML
      files as generated from the test description; and
    - a `<test.fmt>.test.html` file, generated by the validator when the test
      is run (useful when debugging and writing tests).

You can remove all generated files by running `python3 runner.py clean`.

Test descriptions
-----------------

Tests can currently only be described using YAML (TODO: also support JDOT when
this stabilizes). Any `*.yaml` file found recursively in the `tests` folder
(that isn't a generated file, so not `*.test.*.yaml`) is a test case.

The expected input format is structured as follows.

    {
        "name": "<test-name>",
        "diags"?: [
            {
                "code": <code>,
                "min": "<minimum-error-level>",
                "max": "<maximum-error-level>",
            }*
        ],
        "plan": <substrait-plan>
    }

The `"name"` key specifies a friendly name for the test, which is printed by
the runner when it is run and again at the end if it fails.

The `"diags"` key allows diagnostic levels to be overridden. `<code>` is just
the integer diagnostic code, and the error levels can be either `"e"` for
error, `"w"` for warning, or `"i"` for info.

The contents of the `"plan"` key, roughly speaking, correspond to the JSON
serialization structure of the `substrait.Plan` protobuf message. However,
additional keys may be added to objects to give instructions to the test
runner, and YAML extensions can be embedded into the plans.

The checks that the runner must perform are embedded in the plan structure
using `"[sub-path]__test"` keys. Usually, `[sub-path]` is left blank, which
means that the embedded checks relate to the dictionary that key is a part
of, but it may also be set to a period-separated list of subkeys and/or
list indices, to allow `__test` data to be attached to non-dict values. The
data associated with `__test` keys must be a list of dictionaries with the
following format:

    {
        "level"?: [<allowed-error-levels>],
        "diag"?: {
            "code"?: <expected-code>,
            "level"?: <expected-level>,
            "original_level"?: <expected-level>,
            "msg"?: <expected-message-pattern>,
            "before"?: <path-element>,
            "after"?: <path-element>
        },
        "type"?: "expected-type"
    }

Exactly one key must be specified for the outermost dictionary:

 - `"level"` matches the (recursive) error level of the current node, failing
   the test if the actual level is not in the list.
 - `"diag"` removes the first diagnostic attached to the node that complies
   with all patterns from the node's diagnostics, while failing the test if
   no such diagnostic exists. Because the diagnostic is effectively
   removed, subsequent "level" checks can be used to ensure that no
   unexpected diagnostics remain. The following checks can be added:
    - `"code"` matches the diagnostic code exactly;
    - `"level"` matches the adjusted error level exactly;
    - `"original_level"` matches the original error level exactly;
    - `"msg"` matches the error message, using `*` for zero or more characters,
      and `**` as an escape for matching `*` literally;
    - `"before"` only checks for diagnostics that occur before the child with
      the given path element was written;
    - `"after"` only checks for diagnostics that occur after the child with
      the given path element was written.
   The path elements have the following syntax:
    - `"field"`: regular field named "field";
    - `"field[x]"`: element x of repeated field named "field";
    - `"field<variant>"`: oneof field named "field" with variant "variant";
    - `"[x]"` -> YAML list index x.
   Fields and variants that aren't valid identifiers can be specified using
   double-quoted strings, using `\"` and `\\` as escape sequences, but be aware
   that the serialization format you're writing may want non-identifier things
   to be quoted, too. For example, in YAML, a field with named `!` would be
   written as `'"!"'`, the single quotes delimiting the YAML string.
 - `"type"` matches the (final) data type attached to the node with the given
   string. There's no intelligence here; the string must match exactly.

Evaluation order is depth-first, so diagnostics attached to child nodes are
removed before the level of their parent node is checked.

`<key>__yaml` keys may be used in place of URI keys to embed extension YAML
files. The key will be replaced with `"<key>"`, set to the string
`"test:<index>.yaml"`. The corresponding YAML file is written to
`"<test.fmt>.<index>.yaml"`. The test runner installs a custom URI handler
with the validator to ensure that the extension file will be linked up
appropriately.

Just like the protobuf message structure, the embedded YAML data may have
`__test` tags associated with it, so check instructions can also be attached
to the extension
files.
